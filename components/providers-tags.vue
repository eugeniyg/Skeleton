<template>
  <div class="providers-tags" v-if="tags.length">
    <div class="providers-tags__clear" @click="clearTags">
      <atomic-icon id="trash" class="providers-tags__clear-icon"/>
      
      <span class="providers-tags__clear-text">
        {{ getContent(popupsData, defaultLocalePopupsData, 'providers.clearTags') }}
      </span>
    </div>
    
    <div class="providers-tags__content">
      <div class="providers-tags__items" ref="scrollContainer" @scroll="scrollHandler">
        <div
          class="providers-tags__item"
          v-for="tag in props.tags"
          :key="tag.id"
        >
          <span class="providers-tags__item-text">{{ tag.name }}</span>
          <atomic-icon id="close" class="providers-tags__item-icon" @click="unselectTag(tag.id)"/>
        </div>
      </div>
      
      <div class="providers-tags__buttons">
        <div
          class="providers-tags__prev"
          :class="{ 'is-disabled': prevDisabled }"
          @click="clickAction('prev')"
        >
          <atomic-icon id="arrow_expand-close"/>
        </div>
        
        <div
          class="providers-tags__next"
          :class="{ 'is-disabled': nextDisabled }"
          @click="clickAction('next')"
        >
          <atomic-icon id="arrow_expand-close"/>
        </div>
      </div>
    </div>
  
  </div>
</template>

<script setup lang="ts">
  import type { IGameProvider } from '@skeleton/core/types';
  
  const props = defineProps<{
    selected: string[],
    tags: IGameProvider[],
  }>();
  
  const {
    popupsData,
    defaultLocalePopupsData
  } = useGlobalStore();
  
  const { getContent } = useProjectMethods();
  
  const scrollContainer = ref();
  const prevDisabled = ref<boolean>(true);
  const nextDisabled = ref<boolean>(false);
  
  const scrollHandler = (): void => {
    if (!scrollContainer.value) return;
    const {
      scrollLeft,
      offsetWidth,
      scrollWidth
    } = scrollContainer.value;
    prevDisabled.value = scrollLeft === 0;
    nextDisabled.value = scrollWidth < (scrollLeft + offsetWidth + 20) && scrollWidth > (scrollLeft + offsetWidth - 20);
  };
  
  const clickAction = (direction: string): void => {
    const {
      offsetWidth,
      scrollWidth,
      scrollLeft
    } = scrollContainer.value;
    const widthToEnd = scrollWidth - (scrollLeft + offsetWidth);
    const scrollLeftValue = widthToEnd < offsetWidth ? widthToEnd : offsetWidth;
    const scrollRightValue = scrollLeft < offsetWidth ? scrollLeft : offsetWidth;
    
    scrollContainer.value.scrollBy({
      left: direction === 'next' ? scrollLeftValue : -scrollRightValue,
      behavior: 'smooth',
    });
  };
  
  const emit = defineEmits(['unselect']);
  
  const unselectTag = (providerId: string) => {
    emit('unselect', props.selected.filter(id => id !== providerId));
  };
  
  const clearTags = () => {
    emit('unselect', []);
  };
  
  watch(() => props.tags, () => {
    nextTick(() => {
      scrollHandler();
    });
  });
  
  onMounted(() => {
    window.addEventListener('resize', scrollHandler);
    scrollHandler();
  });
  
  onUnmounted(() => {
    window.removeEventListener('resize', scrollHandler);
  });
</script>

<style src="~/assets/styles/components/providers-tags.scss" lang="scss"/>
